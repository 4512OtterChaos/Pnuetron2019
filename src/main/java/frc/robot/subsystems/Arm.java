// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package frc.robot.subsystems;


import com.ctre.phoenix.motorcontrol.ControlMode;
import com.ctre.phoenix.motorcontrol.DemandType;
import com.ctre.phoenix.motorcontrol.FeedbackDevice;
import com.ctre.phoenix.motorcontrol.StatusFrame;
import com.ctre.phoenix.motorcontrol.can.WPI_TalonSRX;

import frc.robot.Config;
import frc.robot.Convert;
import frc.robot.Network;
import frc.robot.PIDConstants;
import frc.robot.Robot;
import frc.robot.commands.ArmManual;

import edu.wpi.first.wpilibj.command.Subsystem;

public class Arm extends Subsystem {

    public WPI_TalonSRX wrist;

    private double target = 280;
    private double targetA = target;//adjusted target
    private double akP = 2.2;
    private double akI = 0;
    private double akD = 60;
    private double akF = 1023.0/225.0;
    private double akPeak = 1;
    private double akRamp = 0.09;
    private double akAllowable = 25;
    private int akCruise = 130;
    private int akCruiseItem = 110;
    //private double akAccelTime = 0.9;//seconds (1.1)
    private int akAccel = 260;
    private int akAccelItem = 210;
    //behavior constants
    private final double akAntiArm = 0.08;//percent with unburdened arm
    private final double akAntiItem = 0.13;//percent with burdened arm
    private double akAntiGrav = akAntiArm;//How much PercentOutput is required for the motor to stall while horizontal
    public final int akMinB = Convert.getCounts(-85);//0 degrees straight up, positive forward
    public final int akMaxB = Convert.getCounts(-75);
    public final int akMinF = Convert.getCounts(23);
    public final int akMaxF = Convert.getCounts(120);
    public final int akHatchOutFree = Convert.getCounts(80);
    public final int akHatchOutItem = Convert.getCounts(78);
    public int akHatchOutF = akHatchOutFree;
    public final int akHatchOutB = akMinB;
    //state
    private int pos;
    private double deg;
    private boolean manual=false;
    private boolean carrTop;
    private boolean liftResting;
    private boolean intakeBackdrive;
    private boolean armOver;
    private boolean armWantOver;
    private boolean armNullZone;
    private boolean armHasItem;

    public Arm() {
        wrist = new WPI_TalonSRX(7);

        Config.configAllStart(wrist);

        wrist.configSelectedFeedbackSensor(FeedbackDevice.CTRE_MagEncoder_Absolute, PIDConstants.kIdx, Config.kTimeout);
        wrist.setStatusFramePeriod(StatusFrame.Status_13_Base_PIDF0, 10, Config.kTimeout);
        Config.configSensor(wrist, 280);
        wrist.setInverted(false);
        wrist.setSensorPhase(false);
        Config.configCruise(akCruise, wrist);
        Config.configAccel(akAccel, wrist);
        wrist.configMotionSCurveStrength(4, Config.kTimeout);
        Config.configClosed(wrist, akP, akI, akD, akF, akPeak, akRamp);
    }

    @Override
    public void initDefaultCommand() {
        setDefaultCommand(new ArmManual());
        // Set the default command for a subsystem here.
        // setDefaultCommand(new MySpecialCommand());
    }

    @Override
    public void periodic() {
        // Put code here to be run every loop
        checkState();
        
        targetA=Math.max(((intakeBackdrive&&!armHasItem)? Convert.getCounts(7):akMinF), targetA);
        targetA=Convert.limit(akMinB, akMaxF, targetA);
        if(liftResting){
            targetA=285;
        }

        double feed = (liftResting)? 0.06:calcGrav();
        if(!manual) aMotionPID(targetA, feed);

        putNetwork();
    }

    // Put methods for controlling this subsystem
    // here. Call these from Commands.
    private void checkState(){//state changes
        pos=wrist.getSelectedSensorPosition();
        deg=Convert.getDegrees(pos);
        intakeBackdrive=Robot.intake.getBackdriving();
        armHasItem=Robot.manipulator.getIsOpen();
        if(armHasItem){
            akHatchOutF=akHatchOutItem;
            Config.configCruise(akCruiseItem, wrist);
            Config.configAccel(akAccelItem, wrist);
        }
        else{
            akHatchOutF=akHatchOutFree;
            Config.configCruise(akCruise, wrist);
            Config.configAccel(akAccel, wrist);
        }
        akAntiGrav=(armHasItem)? akAntiItem:akAntiArm;
        targetA=target;
        armNullZone=(deg<=akMinF-4 && deg>=akMaxB+4);
        armOver=deg<1;
        armWantOver=
            (armOver&&target>=0-akAllowable) ||
            (!armOver&&target<=0+akAllowable) && !intakeBackdrive;
        carrTop=Robot.elevator.getCarrTop();
        liftResting=Robot.elevator.getIsResting();
        //feed
    }
    private void putNetwork(){
        Network.put("Arm Target", target);
        Network.put("Arm TargetA", targetA);
        Network.put("Arm Pos", pos);
        Network.put("Arm Deg", deg);
        Network.put("Arm Native", Convert.getNative(wrist));
        Network.put("Arm Power", wrist.getMotorOutputPercent());
    }
    
    private void aMotionPID(double pos){
		wrist.set(ControlMode.MotionMagic, pos);
	}
	private void aMotionPID(double pos, double feed){
		wrist.set(ControlMode.MotionMagic, pos, DemandType.ArbitraryFeedForward, feed);
	}
	private void aPosPID(double pos){
		wrist.set(ControlMode.Position, pos);
	}
	private void aPosPID(double pos, double feed){
		wrist.set(ControlMode.Position, pos, DemandType.ArbitraryFeedForward, feed);
    }

    private double calcGrav(){//resist gravity
        double gravity = -Math.sin(Math.toRadians(deg));//0 degrees is straight up, so gravity is a sin curve
        double counterForce = (gravity*akAntiGrav);//multiply by the output percent for holding stable while 90 degrees
        counterForce = Convert.limit(counterForce);
        return counterForce;
    }
    
    //interaction
    public boolean isTarget(){
        return (pos<=target+akAllowable && pos>=target-akAllowable);
    }
    public boolean isTarget(int t){
        return (pos<=t+akAllowable && pos>=t-akAllowable);
    }
    
    public int getPos(){
        return pos;
    }
    public double getDeg(){
        return deg;
    }
    public boolean getIsOver(){
        return armOver;
    }
    public boolean getWantOver(){
        return armWantOver;
    }
    public boolean getIsNull(){
        return armNullZone;
    }
    public boolean getHasItem(){
        return armHasItem;
    }

    public void setHasItem(boolean has){
        armHasItem=has;
    }

    public void setTarget(int t){
        target=t;
    }
    public void setIsManual(boolean b){
        manual=b;
    }
    public void setWrist(double x){
		wrist.set(ControlMode.PercentOutput, x, DemandType.ArbitraryFeedForward, calcGrav());
    }
}

