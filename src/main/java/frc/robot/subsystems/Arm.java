// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package frc.robot.subsystems;


import com.ctre.phoenix.motorcontrol.ControlMode;
import com.ctre.phoenix.motorcontrol.DemandType;
import com.ctre.phoenix.motorcontrol.FeedbackDevice;
import com.ctre.phoenix.motorcontrol.StatusFrame;
import com.ctre.phoenix.motorcontrol.can.WPI_TalonSRX;

import frc.robot.common.*;
import frc.robot.Robot;
import frc.robot.RobotMap;
import frc.robot.subsystems.armCommands.*;
import frc.robot.subsystems.manipulatorCommands.*;
import edu.wpi.first.wpilibj.DigitalInput;
import edu.wpi.first.wpilibj.command.Scheduler;
import edu.wpi.first.wpilibj.command.Subsystem;

public class Arm extends Subsystem {

    public WPI_TalonSRX wrist;

    public DigitalInput hatchButton = new DigitalInput(4);

    private final int startPos = 280;
    private int target = startPos;
    private int targetA = target;//adjusted target
    private double akP = 2.2;
    private double akI = 0;//0.01
    private double akD = 50;
    private double akF = 1023.0/210.0;
    private double akPeak = 1;
    private double akRamp = 0.08;
    private int akCruise = 130;
    private int akCruiseItem = 110;
    private int akAccel = 260;
    private int akAccelItem = 210;
    //behavior constants
    private final double akRestingForce = 0.05;//forward pressure while resting
    private final double akAntiArm = 0.08;//percent with unburdened arm(counter gravity)
    private final double akAntiItem = 0.13;//percent with burdened arm
    //state
    private int pos = startPos;
    private boolean manual=false;
    private boolean armHasItem = false;
    private boolean armHadItem = false;
    private boolean armGotItem = false;
    private boolean armLostItem = false;
    private boolean button = false;
    private boolean lastButton = false;
    private boolean buttonPressed = false;
    private boolean buttonReleased = false;

    public Arm() {
        wrist = new WPI_TalonSRX(7);

        Config.configAllStart(wrist);

        wrist.configSelectedFeedbackSensor(FeedbackDevice.CTRE_MagEncoder_Absolute, RobotMap.P_IDX, Config.kTimeout);
        wrist.setStatusFramePeriod(StatusFrame.Status_13_Base_PIDF0, 30, Config.kTimeout);
        Config.configSensor(wrist, startPos);
        wrist.setInverted(false);
        wrist.setSensorPhase(false);
        Config.configCruise(akCruise, wrist);
        Config.configAccel(akAccel, wrist);
        wrist.configMotionSCurveStrength(6, Config.kTimeout);
        Config.configClosed(wrist, akP, akI, akD, akF, akPeak, akRamp);
        wrist.config_IntegralZone(RobotMap.P_IDX, RobotMap.ARM_ERROR, Config.kTimeout);
    }

    @Override
    public void initDefaultCommand() {
        setDefaultCommand(new ArmManual());
        // Set the default command for a subsystem here.
        // setDefaultCommand(new MySpecialCommand());
    }

    @Override
    public void periodic() {
        // Put code here to be run every loop
        checkState();

        if(armGotItem){
            Config.configCruise(akCruiseItem, wrist);
            Config.configAccel(akAccelItem, wrist);
        }
        else if(armLostItem){
            Config.configCruise(akCruise, wrist);
            Config.configAccel(akAccel, wrist);
        }

        if(buttonPressed){
            if(!armHasItem){
                Scheduler.getInstance().add(new OpenClaw());
            }
            else{
                Scheduler.getInstance().add(new PlaceHatch());
            }
        }
        
        targetA=target;

        //intake compensate
        targetA=Math.max(((Robot.intake.getBackdriving() && !getHasItem())? Convert.getCounts(7):RobotMap.ARM_CLOSE_FORWARD), targetA);
        //avoid pegs
        targetA=Math.min(((Robot.elevator.getPos()<=RobotMap.ELEV_SUPPLY+RobotMap.ELEV_ERROR)? RobotMap.ARM_HATCH_OUT:RobotMap.ARM_FAR_FORWARD), targetA);
        //avoid pid pressure
        targetA=Math.min(((Robot.elevator.getPos()<=RobotMap.ELEV_SUPPLY-RobotMap.ELEV_ERROR)? startPos:RobotMap.ARM_FAR_FORWARD), targetA);
        //dont break the chain
        targetA=Convert.limit(RobotMap.ARM_FAR_BACKWARD, RobotMap.ARM_FAR_FORWARD, targetA);

        double ff = calcGrav();//feed forward

        boolean liftResting = Robot.elevator.getIsResting();
        boolean armResting = 
            (isTarget(target, RobotMap.ARM_HATCH_IN) && (isTarget(RobotMap.ARM_HATCH_IN)))
            && Robot.elevator.getPos()<=RobotMap.ELEV_SUPPLY+RobotMap.ELEV_ERROR;
        
        if(liftResting){
            targetA=startPos;//set to resting angle
            ff=akRestingForce;//forward pressure on arm while down
        }

        if(liftResting||armResting) setWrist(akRestingForce);
        else if(!manual) aMotionPID(targetA, ff);

        putNetwork();
    }

    // Put methods for controlling this subsystem
    // here. Call these from Commands.
    private void checkState(){//state changes
        pos=getPos();

        armHasItem=getHasItem();
        armGotItem=armHasItem&&!armHadItem;
        armLostItem=!armHasItem&&armHadItem;
        armHadItem=armHasItem;

        button=hatchButton.get();
        buttonPressed=button&&!lastButton;
        buttonReleased=!button&&lastButton;
        lastButton=button;      
    }
    private void putNetwork(){
        Network.put("Arm Target", target);
        Network.put("Arm TargetA", targetA);
        Network.put("Arm Pos", pos);
        Network.put("Arm Deg", getDeg());
        Network.put("Arm Native", Convert.getNative(wrist));
        Network.put("Arm Power", wrist.getMotorOutputPercent());
    }
    
    private void aMotionPID(double pos){
		wrist.set(ControlMode.MotionMagic, pos);
	}
	private void aMotionPID(double pos, double feed){
		wrist.set(ControlMode.MotionMagic, pos, DemandType.ArbitraryFeedForward, feed);
	}

    private double calcGrav(){//resist gravity
        double gravity = -Math.sin(Math.toRadians(getDeg()));//0 degrees is straight up, so gravity is a sin curve
        double counterForce = (gravity*((getHasItem())? akAntiItem:akAntiArm));//multiply by the output percent for holding stable while 90 degrees
        counterForce = Convert.limit(counterForce);
        return counterForce;
    }
    
    //interaction
    public boolean isTarget(){
        return (pos<=target+RobotMap.ARM_ERROR && pos>=target-RobotMap.ARM_ERROR);
    }
    public boolean isTarget(int t){
        return (pos<=t+RobotMap.ARM_ERROR && pos>=t-RobotMap.ARM_ERROR);
    }
    public boolean isTarget(int pos, int target){
        return (pos<=target+RobotMap.ARM_ERROR && pos>=target-RobotMap.ARM_ERROR);
    }
    
    public int getPos(){
        return wrist.getSelectedSensorPosition();
    }
    public double getDeg(){
        return Convert.getDegrees(getPos());
    }
    public int getTarget(){
        return target;
    }
    public boolean getHasItem(){
        return Robot.manipulator.getIsOpen();
    }

    public void setTarget(int t){
        target=t;
    }
    public void setIsManual(boolean b){
        manual=b;
    }
    public void setWrist(double x){
		wrist.set(ControlMode.PercentOutput, x, DemandType.ArbitraryFeedForward, calcGrav());
    }
}

