// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package frc.robot.subsystems;

import com.ctre.phoenix.motorcontrol.ControlMode;
import com.ctre.phoenix.motorcontrol.FeedbackDevice;
import com.ctre.phoenix.motorcontrol.InvertType;
import com.ctre.phoenix.motorcontrol.StatusFrame;
import com.ctre.phoenix.motorcontrol.can.WPI_TalonSRX;

import frc.robot.RobotMap;
import frc.robot.common.*;
import frc.robot.subsystems.driveCommands.*;

import edu.wpi.first.wpilibj.command.Subsystem;

public class Drive extends Subsystem {

    public WPI_TalonSRX frontRight;
    public WPI_TalonSRX backRight;
    public WPI_TalonSRX frontLeft;
    public WPI_TalonSRX backLeft;

    //pid
    private double dkP = 0.5;
    private double dkI = 0;
    private double dkD = 40;
    private double dkF = 1023/2600.0;
    private double dkPeak = 1;
    private double dkRamp = 0.175;
    //state
    private final double dkMaxRPM = 400;
    public final double dkSpeedNeutral = 0.45;
    public final double dkSpeedLow = 0.2;
    private double dkSpeedShift = dkSpeedNeutral;
    private double dkSpeedDefault = dkSpeedLow;
    private double dkSpeed = dkSpeedDefault;
    private double targetRPM = dkMaxRPM*dkSpeed;
    private double forward = 0;
    private double turn = 0;

    /*
    public ChassisState solveForwardKinematics(final WheelState wheel_motion) {
        ChassisState chassis_motion = new ChassisState();
        chassis_motion.linear = wheel_radius_ * (wheel_motion.right + wheel_motion.left) / 2.0;
        chassis_motion.angular = wheel_radius_ * (wheel_motion.right - wheel_motion.left) / (2.0 *
                effective_wheelbase_radius_);
        return chassis_motion;
    }
    */

    public Drive() {
        frontRight = new WPI_TalonSRX(RobotMap.DRIVE_F_RIGHT);
        
        backRight = new WPI_TalonSRX(RobotMap.DRIVE_B_RIGHT);
        
        frontLeft = new WPI_TalonSRX(RobotMap.DRIVE_F_LEFT);
        
        backLeft = new WPI_TalonSRX(RobotMap.DRIVE_B_LEFT);
        
        //config basic things
        Config.configAllStart(frontRight);
        Config.configAllStart(frontLeft);
        Config.configAllStart(backRight);
        Config.configAllStart(backLeft);
        //config behavior
        backRight.follow(frontRight);
        backLeft.follow(frontLeft);
        frontRight.configSelectedFeedbackSensor(FeedbackDevice.CTRE_MagEncoder_Relative, RobotMap.P_IDX, Config.kTimeout);
        frontRight.setStatusFramePeriod(StatusFrame.Status_13_Base_PIDF0, 30, Config.kTimeout);
        frontRight.setInverted(true);
        backRight.setInverted(InvertType.FollowMaster);
        frontRight.setSensorPhase(true);
        frontLeft.configSelectedFeedbackSensor(FeedbackDevice.CTRE_MagEncoder_Relative, RobotMap.P_IDX, Config.kTimeout);
        frontLeft.setStatusFramePeriod(StatusFrame.Status_13_Base_PIDF0, 30, Config.kTimeout);
        frontLeft.setInverted(false);
        backLeft.setInverted(InvertType.FollowMaster);
        frontLeft.setSensorPhase(true);
        Config.configClosed(frontRight, dkP, dkI, dkD, dkF, dkPeak, dkRamp);
        Config.configClosed(frontLeft, dkP, dkI, dkD, dkF, dkPeak, dkRamp);
    }

    @Override
    public void initDefaultCommand() {
        // Set the default command for a subsystem here.
        // setDefaultCommand(new MySpecialCommand());
        setDefaultCommand(new DriveManual());
    }

    @Override
    public void periodic() {
        // Put code here to be run every loop
        checkState();

        dVelPID(forward, turn);

        putNetwork();
    }

    // Put methods for controlling this subsystem
    // here. Call these from Commands.
    private void checkState(){
        targetRPM=dkMaxRPM*dkSpeed;
    }
    private void putNetwork(){
        Network.put("Left Drive Native", Convert.getNative(frontLeft));
        Network.put("Right Drive Native", Convert.getNative(frontRight));
    }
    
    /**
     * Velocity PID control. Given a percentage forward/turn, calculate
     * the speed both sides should be at to replicate desired input.
     * This lets us mimic arcade drive with the benefits of PID(voltage/load compensation)
     * @param forward Percentage forward
     * @param turn Percentage turn
     */
    private void dVelPID(double forward, double turn){
		//double right = arcadeMath(forward, -turn);
        //double left = arcadeMath(forward, turn);
        double turnWeight = 1.2-(Math.abs(forward)*0.5);
        turn*=turnWeight;
        double right = Convert.limit(forward-turn);
        double left = Convert.limit(forward+turn);
		right = calc100ms(right, targetRPM);
		left = calc100ms(left, targetRPM);
		frontRight.set(ControlMode.Velocity, right);
		frontLeft.set(ControlMode.Velocity, left);
    }

	/**
	 * Basic arcade drive control.
	 * @param forward Percentage forward(-1 to 1).
	 * @param turn Percentage turn(-1 to 1).
	 */
	private void arcadeDrive(double forward, double turn){
		double right = arcadeMath(forward, -turn);
        double left = arcadeMath(forward, turn);
        tankDrive(left,right);
		//dRightF.set(ControlMode.PercentOutput, forward, DemandType.ArbitraryFeedForward, -turn);
		//dLeftF.set(ControlMode.PercentOutput, forward, DemandType.ArbitraryFeedForward, +turn);
	}
	/**
	 * 
	 * @param forward Percentage forward(-1 to 1).
	 * @param turn Percentage turn(-1 to 1).
	 * @param right If this is the right or left side.
	 * @return Desired speed for certain side to perform arcade drive.
	 */
	private double arcadeMath(double forward, double turn){
        return Convert.limit(forward+turn);
	}
	/**
	 * Returns a percentage rpm as native talon units per 100 ms.
	 * @param percentOutput Percentage of range(-1 to 1).
	 * @param range Maximum range of speed(rpm).
	 * @return Native talon units per 100 ms.
	 */
	private double calc100ms(double percentOutput, double range){//percentage rpm as native units
		double tRPM = percentOutput*range;
		return Convert.getNative(tRPM);//talons use sensor units per 100ms(native units)
	}

	/**
	 * Basic tank drive control.
	 * @param left Desired left speed.
	 * @param right Desired right speed.
	 */
    private void tankDrive(double left, double right){
		left*=dkSpeed;
		right*=dkSpeed;
		setDrive(left, right);
    }

    //interaction
    public double getDriveSpeed(){
        return dkSpeed;
    }

    public void shiftAlternate(){
        shiftSet(dkSpeedShift);
    }
    public void shiftDefault(){
        shiftSet(dkSpeedDefault);
    }
    /**
     * Manually sets percentage speed
     * @param speed Percentage speed(0-1)
     */
    public void shiftSet(double speed){
        dkSpeed=Convert.limit(0,1,speed);
    }

    public void setDefaultSpeed(double speed){
        dkSpeedDefault=speed;
    }
    public void setAlternateSpeed(double speed){
        dkSpeedShift=speed;
    }
    
    /**
     * Sets the target forward speed
     * @param _forward Percentage forward
     */
    public void setForward(double _forward){
        forward=_forward;
    }
    /**
     * Sets the target turn speed
     * @param _turn Percentage turn
     */
    public void setTurn(double _turn){
        turn=_turn;
    }

    /**
     * Manually set the drivebase in simple Percentage operation(tankdrive).
     * @param left Left-side percentage output.
     * @param right Right-side percentage output.
     */
    public void setDrive(double left, double right){
		frontRight.set(ControlMode.PercentOutput, right);
		frontLeft.set(ControlMode.PercentOutput, left);
    }

}

